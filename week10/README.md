План за упражнението

От миналия път:
* Circular dependency

* шаблони на фунцкии (swap, min)

* шаблони на класове
  * типове по подразбиране

- клас pair
- шаблонен вектор
  

# Шаблони
 
## Шаблони на функции

Следната функция разменя стойностите на две променливи от тип `int`:
```c++
void mySwap(int& a, int& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

Ако се наложи да се използва за `double` трябва да се дефинира и за `double` такава:
```c++
void mySwap(double& a, double& b)
{
    int tmp = a;
    a = b;
    b = tmp;
}
```

Ако се наложи да се използва за някой друг тип (както вграден, така и потребителски дефиниран) налага се да се дефинира и за него. Единствената разлика във всички тези дефиниции е името на типа, а един и същ код се пише на много места. 

За да се предотврати повторението на един и същ код на много места въвеждат се така наречените шаблони. Шаблон за функцията `mySwap` ще изглежда по следния начин:
```c++
template <typename T>
void mySwap(T& a, T& b)
{
    K tmp = a;
    a = b;
    b = tmp;
}
```
Пише се ключовата дума `template` и след нея в `< >` се изреждат типовете, които ще се използват. В примера с `mySwap` има само един тип. Тук `T` представлява типа, с който се извиква функцията и навсякъде, където се среща `T` във функцията се замества с името на типа. На мястото на `T` може да стои някоя друга буква или дума. `typename` пред `T` означава, че това е име на тип. Тук вместо `typename` може да се пише и `class`, значението е същото. Пример:
```c++
template <class K> 
K max(K a, K b)
{
    return a > b ? a : b;
}
```
Тази функция връща стойността на по-големия по стойност от двата подадени аргумента. 
Няма ограничение за броя различни типове, които могат да участват в шаблоните. Пример:
```c++
    template <typename T, typename K, typename V>
    void foo(T first, T second, K third, V fourth)
    {
        // ...
    }
```

#### Извикване на шаблонни функции
```c++
    double a = 3.3;
    double b = 4.2;
    swap(a, b);
    max(a, b);    
```
Компилатора определя типа по подадените стойности. 
```c++
    max(3.3, 3.2);
```
В горния случай не се подават променливи от тип `double`, а дробни числа. Тук компилатора отново ще създаде и направи извикване към функция за тип `double`. Но ако се иска да се сравняват като `int`, тогава трябва експлицитно да се укаже това по следния начин:
```c++
    max<int>(3.3, 3.2);
```

#### Шаблоните не се компилират
Шаблоните указват начин, по-който компилатора да създава функции. Ако не се използва функията за определени типове, тогава няма да бъде създавана за тях. Когато се срещне извикване на шаблонна функция за някой тип, тогава компилатора създава тази функция, "гледайки" от шаблона. По-просто казано, ако се извиква функцията `max(3, 4)` компилатора вижда, че се извиква с `int` и навсякъде, където среща `К` в дефиницията на шаблона слага `int` и компилира тази функиця.

Шаблонните функции могат за някой тип да работят, но за друг да не работят. Понеже шаблоните не се компилират, това не може да се знае, докато не се направи извикване на функцията със съответен тип. Например в шаблона за функцията `max` се използва оператора `>`. Ако някой клас няма предефиниран този оператор тази функция няма да се компилира за него. Но това няма да се разбере, докато не се направи извикване за този клас.

#### Специализация на функции
За определен тип може да се укаже функцията да има различно поведение от общия шаблон. Например функцията `max` сравнява с оператора `>` и ако се иска за `int` да сравнява с оператора `>=`, тогава трябва да се направи по следния начин:
```c++
// това ще се използва за всички типове, освен int
K max(K a, K b)
{
    return a > b ? a : b;
}

// когато има извикване за int ще се използва тази функция
int max(int a, int b)
{
    return a >= b ? a : b;
}
```

Тук трябва да се обърне внимание, че ако фунцкията се извиква по този начин: `max(3, 4)` ще се извика "специалната" версия. Обаче, ако се извиква по този начин: `max<int>(3,4)`, тогава вече се извиква шаблонната версия.

## Шаблони на класове
Както съществуват шаблони на функции, така съществуват и шаблони на класове. Синтаксиса е същия като при функциите, преди дефиницията на класа се пише `template <typename ...>`.
Като пример разгледайте класа `Pair`, който прилича на [std::pair](https://en.cppreference.com/w/cpp/utility/pair):
```c++
template <typename F, typename S>
class Pair;

template<typename F, typename S>
std::ostream& operator<<(std::ostream& o, const Pair<F, S>& p);

template <typename F = int, typename S = int>
class Pair
{
	F first;
	S second;

	Pair(F first, S second) : first(first), second(second) {}

	bool operator<(const Pair&) const;

	friend std::ostream& operator<< <> (std::ostream&, const Pair&);
};

template<typename F, typename S>
bool Pair<F, S>::operator<(const Pair& other) const
{
	return first < other.first && second < other.second;
}

template<typename F, typename S>
std::ostream& operator<<(std::ostream& o, const Pair<F, S>& p)
{
	return o << "(" << p.first << ", " << p.second << ")";
}
```

В случай, когато има приятелски функции на класа, които също трябва да са шаблонни се налага да се декларират преди тялото на класа, за да знае компилатора, че те са шаблонни. Иначе ще ги търси като обикновени (не шаблонни). Но за да може в декларацията да имат параметри от класа, трябва той да е деклариран преди тях, както е направено в примера с `Pair` на първите редове. Последно нещо, което трябва да се направи, е да се добави `<>` след името на приятелските функции, там където се декларират като приятели (вътре в тялото на класа).

Друг вариант е да се дефинират вътре в тялото на класа, както тук:
```c++
template <typename F = int, typename S = int>
class Pair
{
	F first;
	S second;

	Pair(F first, S second) : first(first), second(second) {}

	bool operator<(const Pair&) const;

	friend std::ostream& operator<<(std::ostream& o, const Pair& p)
    {
        return o << "(" << p.first << ", " << p.second << ")";
    }
};

template<typename F, typename S>
bool Pair<F, S>::operator<(const Pair& other) const
{
	return first < other.first && second < other.second;
}
```

Шаблонните функции може да се извикват без да се указват от кой тип са и спрямо аргументите компилаторът да одгатне кои са типовете. При класовете трябва експлицитно да се казва с кои типове се иска да се използва класа.  

Пример за използване на `Pair`:
```c++
    Pair<int, double> p(1, 2.5);
    std::cout << p << '\n';
```

В списъка с типовете може да се добавят типове по подразбиране, за които важи същото правило както за параметрите по подразбиране при функциите - подразбиращите се типове трябва да са в края.
Тогава може да се създава обект от този клас без да се указват типовете, но трябва да има `<>`. Пример:
```c++
    Pair<> p(1, 2);
    std::cout << p < Pair<>(0, 1);
```

### Шаблони на класове и разделна компилация
Дефинициите на методите трябва да са или вътре в тялото на класа (вградени функции) или ако ще са извън класа да са в същия `.hpp` файл. Тук няма възможност за разделна компилация, защото шаблоните не се компилират и когато компилатора има нужда да създаде функция от шаблон трябва да може да вижда цялата информация на едно място. Ако дефинициите на методите са вътре в класа, правят се по стандартния начин. Ако се дефинират извън класа прави се по следния начин:
```c++
template<typename F, typename S>
bool Pair<F, S>::operator<(const Pair& other) const
{
	return first < other.first && second < other.second;
}
```
Отново трябва да се укаже, че това е шаблон на функция с първия ред `template<typename F, typename S>` и след това се пише дефиницията, като се указва и областта (класът), в който се намира методът с `Pair<F, S>::`.

#

Най-често задавани въпроси относно шаблони може да намерите [тук](https://isocpp.org/wiki/faq/templates).