# План за упражнението

- Член-функции
  - this
  - const
  - вградени (inline) функции

- Селектори и мутатори

- Конструктор и деструктор
  - конструктор по подразбиране
  - конструктор с параметри
  - инициализиращ списък 

- Жизнен цикъл на обект

- Модификатори за достъп

- Клас

- Работа с обекти в динамичната памет

- Сериализация на обекти с динамична памет

# Полезна информация

## Основни ООП принципи
- Енкапсулация
- Абстракция
- Наследяване
- Полиморфизъм

## Класове
- член-данни
- член-функции (методи)
- конструктори 

## Член-данни от същия тип

- директна рекурсия 
```c++
class MyClass {

    int var;
    MyClass obj; //забранено

public:

    void print();

};
```

- чрез указател
```c++
class MyClass {

    int var;
    MyClass* obj; //позволено

public:

    void print();

};
```

### Обекти
- инстанции на класове (променливи от този тип клас)

## Конструктори
- конструктор по подразбиране:  ``MyClass()``
- конструктор с параметри:  ``MyClass(int)``

```c++
class MyClass {

    int var;

public:
    MyClass(); //default constructor
    MyClass(int); //constructor with parameters
    void print();

};
```

Извикване на контруктор:
```c++
    MyClass var; //default constructor called
    MyClass var(5); //implicit call
    MyClass var = MyClass(5); //explicit call
```

### Конструктор по подразбиране
Конструктор без параметри. Ако не е дефиниран нито един конструктор, автоматично се създава конструктор по подразбиране.

### Конструктор с параметри

### Конструктор с параметри по подразбиране
- Какво е функция с параметри по подразбиране?  
```c++
    Rational(int num = 0, int denom = 1); 
    //Rational(int num = 0, int denom); -- грешно!
```
- Възможни извиквания на така дефиниран конструктор
```c++
    Rational();
    Rational(5);
    Rational(5, 3);
```

### Инициализиращ списък (Member initializer list)

- задават се стойности на член-данните по време на тяхната дефиниция (преди тялото на конструктора).
Пример:
```c++
    Rational::Rational(int num, double denom) : numerator(num), denominator(denom) {}
```
- иначе първо се заделя паметта (извиква се конструктора по подразбиране за обекти) и след това се присвояват стойностите. 
Пример:
```c++
    Rational::Rational(int num, int denom) 
    {   
        this->numerator = num;
        this->denominator = denom;
    }
```
- позволява инициализация на константи. Пример:
    ```c++
        class Example {
            const int MY_CONST;
            int var;

        public:
            Example(int constValue, int Var) : MY_CONST(constValue), var(Var) {}
        }
    ```
    - защо следното няма да работи:
    ```c++
        Example(int constValue, int Var) : var(Var) {
                MY_CONST = constValue;
            }
    ```

### this
- указател към текущия обект
- при извикване на функция автоматично се подава константен указател ``this`` като първи аргумент
    - пример: метода ``print()`` от ``MyClass``
    ```c++
        void print(MyClass* const this); 
    ```
    - при извикване на метода ``obj.print()`` се получава ``MyClass::print(&obj);``

### const
- пример: ``void print() const;``
- означава, че този метод не може да променя член-данните на класа
- по-точно метода автоматично получава константен указател към константа 
```c++
    int getVar(MyClass const * const this);
```

### Селектори 
- член-функции за достъп до член-данните на класовете

```c++
    int getVar() const {
        return var;
    }
```

### Мутатори
- член-функции за промяна на член-данните на класовете

```c++
    int setVar(int newValue) {
        this->var = newValue;
    }
```

### Достъп до членовете на класа
- чрез обект
```c++
    MyClass obj;
    obj.print();
```

- чрез указател
```c++
    MyClass *ptr = &obj;
    ptr->print();
    (*ptr).print(); //също като горното
```

### Всеки запис или клас дефинира област (scope)
- за да достъпим членовете извън класа трябва да укажем и името на областта

## Пример с MyClass
### В header файла ``MyClass.hpp`` се съдържа интерфейса на класа

```c++
#pragma once

class MyClass {

    int var;

public:

    MyClass();
    MyClass(int);

    int getVar() const;
    void print() const;

    void setVar(int newVar);
};
```

### В source файла се съдържа имплементацията на класа

```c++
#include "MyClass.hpp"

MyClass::MyClass()
{
    this->var = 0;
}

MyClass::MyClass(int newVar) : var(newVar) {}

int MyClass::getVar() const 
{
    return var;
}

void MyClass::print() const 
{
    std::cout << var << "\n";
}

void MyClass::setVar(int newVar) 
{
    this->var = newVar;
}

```

### Вградени (inline) функции
- тялото им се заместа при всяко тяхно извикване
- такива са:
    - член-функции дефинирани в дефиницията на класа
    - функции, които преди дефиницията имат ключова дума ``inline``
- компилаторът взема крайното решение за това дали дадена функция ще бъде вградена, т.е. даже и да сме декларирали дадена функция като вградена, ако компилаторът прецени, че е по-добре да не е вградена, няма да я направи такава

### Конструктори с точно един параметър
Специален тип конструктори. Където се очаква обект от някой клас `A`, но се подава обект от друг клас (или стойност от вграден тип) `B` и има дефиниран конструктор на `A` с един параметър от тип `B`, тогава този конструктор се извиква с подадения обект (или стойност от вграден тип) като аргумент. 
Пример:
```c++
    class Example {
    public:
        int a;
        int b;

        Example(int A) : a(A), b(100) {} 
    };

    void foo(Example obj) 
    {
        std::cout << obj.a << " " << obj.b << '\n';
    }

    int main()
    {
        foo(3);

        return 0;
    }
```
Този фрагмент код ще изведе ``3 100\n``. 
При извикването на `foo(3)` се създава обект от тип `Example` с помощта на конструктора с един параметър от тип `int`, на който му се подава числото `3`.

### Временни обекти
С помощта на конструкторите могат да се създават обекти, които се използват веднага и след използването им се унищожават.
Пример:
```c++
    Rational(1, 10).print();
```
Тук се създава анонимен обект, извиква се функцията `print()` чрез него и щом приключи изпълнението обекта се унищожава. 

## Деструктори
Деструктора се грижи да се освободи паметта заделена за обекта, когато приключи неговият жизнен цикъл. Например, при излизане от областта, където е дефиниран или при извикване на `delete` (`delete[]`).

Ако не е дефиниран деструктор, той се автоматично създава.

Понякога при създаването на обект или по време на неговия жизнен цикъл се налага да заделяме ресурси, които не са "част от него" (заделяне на динамична памет, отваряне на файл, мрежова връзка...). Следователно, автоматично генерираният деструктор ще изтрие данните за обекта, обаче външните ресурси, които сме заделили ще останат. Затова се налага да си дефинираме деструктор, който ще се грижи ресурсите, които сме заделили, да се освобождават при приключването на жизнения цикъл на обекта.

В примера с класа `Person` заделяме динамична памет за `name`. При унищожаването на обекта (с автоматично дефиниран деструктор) ще се изтрие из паметта указателя `name`, но заделената памет, към която сочи, няма да се изтрие. Затова се налага да се дефинира деструктор, който да се погрижи за това.

```c++
~Person() 
{
    delete[] name;
}
```