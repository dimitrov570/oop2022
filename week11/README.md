# Move семантики

Нека разгледаме следния клас:
```c++
class Student {
  char* name;

  int age;

  void copy_array(const char* other_name) {
    name = new char[strlen(other_name) + 1];
    strcpy(name, other_name);
  }

  void free() {
    delete[] name;
  }

public:

  Student() : name(nullptr) { // name трябва да е nullptr, за да няма грешки при delete[] name
    age = -1;
  }

  Student(const char* _name, int _age) : age(_age) 
  { 
    copy_array(_name);
  }

  Student(const Student& other) : age(other.age) {
    copy_array(other.name);
  }

  Student& operator=(const Student& other) {
  
    if(this != &other) {
      free();

      copy_array(other.name);
      age = other.age;
    }

    return *this;
  }

  ~Student()
  {
    free();
  }
};
```

## lvalue и rvalue

Най-просто казано lvalue са изрази, чийто адрес в паметта може да бъде взет. Пример `Student st;` - `st` е lvalue, понеже обекта `st` живее на някое определено място в паметта и може да бъде променян.
rvalue са изрази които нямат постоянен адрес в паметта, т.е. временни обекти. Пример:
```c++
Student makeStudent(const char* name, int age) {
  Student st(name, age);
  // st
  return st;
}

int main() {
  Student student;
  student = makeStudent("ivan", 22);

  return 0;
}
```
Тук `st` вече е rvalue. rvalue референция можем да прихващаме с `&&`, виж примера по-долу.

Нека видим кои функции се извикват и какво правят при изпълнение на тази програма:
- 1 При създаване на `student` се извиква конструктора по подразбиране.
- 2 Извиква се функцията `makeStudent`, в която:
    - 2.1 извиква се конструктор по подразбиране за създаване на `st`
    - 2.2 при връщане от функцията се извиква конструктор за копиране, който:
      - 2.2.1 **заделя нова памет и копира името**
    - 2.3 извиква се деструктора за `st`
- 3 извиква се опратора за присвояване за да се присвои стойността, върната от `makeStudent`, който:
  - 3.1 **заделя нова памет и копира името**
- 4 деструктор за обекта създаден в точка 2.2  
- 5 в края на програмата деструкор за `student`

Тук имаме две излишни копирания, които можем да спестим дефинирайки move constructor и move operator= по следния начин:
```c++

Student(Student&& other) : name(other.name), age(other.age) {
     other.name = nullptr;
}

Student& operator=(Student&& other) {

    if(this != &other) {
      free();
      name = other.name;
      age = other.age;

      other.name = nullptr;
    }
    
    return *this;
}

```

Параметрите на move конструктора и move оператора за присвояване са rvalue reference (&&) и не са константи.

Какво трябва да правят move конструктора и оператора за присвояване?
- трябва да "вземат" вече заделената памет, от обекта в аргумента. В случая това става като просто се пренасочи указателят `name` към адреса в паметта, където се намира името на обекта от аргумента.
- след това, трябва да остави обекта от аргумента в състояние, което е валидно и безопасно за изпълнението на програмата. За да няма грешка при опит да се освободи паметта два пъти, при обекта от аргумента `name` указателят се прави `nullptr`. Той е във валидно състояние и няма опасност да се освободи паметта за името, при унищожаване на този обект.

Обекта, от който създаваме нов (или присвояваме към друг) чрез move конструктор и оператор за присвояване, е временен и ще бъде унищожен веднага след присвояването. Затова е валидно и по-оптимално да вземем неговите ресурси и да го оставим в такова състояние, което няма да направи проблем при унищожаването му.

Нека видим сега кои функции се извикват и какво правят при изпълнение на същата програма, но сега вече с налични move конструктор и оператор за присвояване:
- 1 При създаване на `student` се извиква конструктора по подразбиране.
- 2 Извиква се функцията `makeStudent`, в която:
    - 2.1 извиква се конструктор по подразбиране за създаване на `st`
    - 2.2 при връщане от функцията се извиква **move** конструктор за копиране, който:
      - 2.2.1 **копира само стойността на указателя `other.name` и прави го `nullptr`**
    - 2.3 извиква се деструктора за `st`
- 3 извиква се **move** опратора за присвояване за да се присвои стойността, върната от `makeStudent`, който:
  - 3.1 **копира само стойността на указателя `other.name` и прави го `nullptr`**
- 4 деструктор за обекта създаден в точка 2.2  
- 5 в края на програмата деструкор за `student`

Тук се спестява време и памет, която се заделяше, когато нямахме move конструктора и оператора за присвояване, в стъпките 2.2.1 и 3.1.

Повече информация:
- https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html
- https://en.cppreference.com/w/cpp/language/move_constructor
- https://stackoverflow.com/questions/3106110/what-is-move-semantics

## std::move

Нека сега в същия клас за името ползваме `std::string`.

```c++
class Student {

  int age;
  std::string name;

public:

  Student() = default;

  Student(const char* _name, int _age) : name(_name), age(_age) 
  { 
 
  }

  Student(Student&& other) : name(std::move(other.name)), age(other.age) {
    
  }

  Student& operator=(Student&& other) {
    if(this != &other) {
      name = std::move(other.name);
      age = other.age;
     }
    return *this;
  }

};
```

Тук вече нямаме нужда да предефинираме конструктор за копиране и оператор за присвояване, защото автоматично генерираните работят както трябва.

При move конструктора, когато ще инициализираме член-данни, които са от тип някой друг клас (не вградени), ако направим в инициализиращия списък следното `: name(other.name), age(other.age)`, тогава името няма да се "премести", т.е. да се извика move конструктора за `std::string`, а ще се копира, т.е. ще се извика конструктора за копиране на `std::string`. Това е така, защото `other.name` не е rvalue. За да го направим такова, ще използваме `std::move`. При оператора за присвояване важи същото правило.